package structColumnDefs

import (
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
)
import "parser/pkg/structColumnTypes"

type ColumnDef struct {
	Name string
	doc  interface{}
}

// header type definitions are from the structColumnType package
// and are used to define the header fields of the column definition.
// These types are generated by the buildHeaderLineTypes.go program.


var builderMap = map[string]*parserBuilder{}

type Parser interface {
	Parse(string) (string, error)
}

type ParserBuilder interface {
	Columns(ColumnDef) ParserBuilder
	Build(string) Parser
}

type parserBuilder struct {
	columnDef ColumnDef
}

type parser struct {
	Columns ColumnDef
}

// aStruct is either a header or a data DataFields struct
func (pb *parser) fillStruct(aStruct interface{}, lineData []string) {
	dataVal := reflect.ValueOf(aStruct)
	for i := 0; i < dataVal.NumField(); i++ {
		switch dataVal.Field(i).Kind() {
		case reflect.Int:
			{
				d, _ := strconv.Atoi(lineData[i])
				dataVal.Field(i).SetInt(int64(d))
			}
		case reflect.Float64:
			{
				d, _ := strconv.ParseFloat(lineData[i], 64)
				dataVal.Field(i).SetFloat(d)
			}
		case reflect.String:
			{
				dataVal.Field(i).SetString(lineData[i])
			}
		case reflect.Bool:
			{
				d, _ := strconv.ParseBool(lineData[i])
				dataVal.Field(i).SetBool(d)
			}
		default:
			{
				fmt.Printf("Unknown type %s\n", dataVal.Field(i).Kind())
			}
		}
	}
}

func (pb *parserBuilder) Columns(columns ColumnDef) ParserBuilder {
	pb.columnDef = columns
	return pb
}

func (pb *parserBuilder) Build(line string) Parser {
	myPb := &parser{
		Columns: pb.columnDef,
	}
	// Build only happens to brand new builders so fill in the header fields
	// of the column definition struct
	headerFieldStruct := reflect.ValueOf(myPb.Columns.doc).FieldByName("HeaderFields")
	lineData := strings.Fields(line)
	myPb.fillStruct(headerFieldStruct, lineData)
	return myPb
}

var lock = &sync.Mutex{}

func (p *parser) Parse(line string) (string, error) {
	fmt.Printf("Parsing the string: %s from %s\n", line, p.Columns.Name)
	dataFieldStruct := reflect.ValueOf(p.Columns.doc).FieldByName("DataFields")
	lineData := strings.Fields(line)
	p.fillStruct(dataFieldStruct, lineData)
	return "parsed", nil
}

func getParser(lineType string, line string) ParserBuilder {
	if builderMap[lineType] == nil {
		pb := &parserBuilder{}
        pb.Columns(structColumnTypes.parserMap[lineType]).Build(line)
        builderMap[lineType] = pb
	}
	return builderMap[lineType]
}

func ParseIt(lineType string, line string) (interface{}, error) {
	// singleton pattern - these are pointers to the parser objects.
	// getParsers() returns a pointer to a particular parser implementation mapped to the lineType.
	// the parser implementation is a struct that implements the Parser interface by having a Parse method
	// and a Columns field that is a struct that implements the ColumnDef interface.

	lock.Lock()
	parser := getParser(lineType, line).(*parser)
	lock.Unlock()
	ret, _err := parser.Parse(line)
	return ret, _err
}
