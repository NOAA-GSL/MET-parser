package structColumnDefs

import (
	"fmt"
	"parser/pkg/structColumnTypes"
	"reflect"
	"strconv"
	"strings"
	"sync"
)

/*
This package is used to define the structs that are used to parse the data for a MET output file.
A Parser is an interface that knows how to parse MET output file lines.
A ParserBuilder is an interface that knows how to build parsers based on the lineType and the Version.
The parserBuilder struct is a concrete implementation of the ParserBuilder interface. It has a columnDef field that
is a struct that implements the ColumnDef interface. The parser struct is a concrete implementation of the Parser interface.
It has a Columns field that is a struct that implements the ColumnDef interface. The parser struct has a Parse method that
knows how to parse a MET output file line. The entry point to this package is the ParseIt function that takes a lineType
and a line and returns a struct that is the result of parsing the line. The ParseIt function needs the lineType because it
cannot get that from the line itself because it doesn't necessarily know the proper index of the lineType in the data line.
It does know the version because that is always the first field. Given the lineType, it can get the proper parser from the
parserMap in the structColumnTypes package. It can then use the parser to parse the line and it can verify that the lineType
is correct by checking the Name field of the parser's Columns field and the LINE_TYPE field that it parses from the data portion
of the line.

Header type definitions are from the structColumnType package
and are used to define the header fields of the column definition.
The entire structColumnType package is generated by the buildHeaderLineTypes.go program.
*/

var builderMap = map[string]Parser{}

type Parser interface {
	// Parser is an interface that knows how to parse things
	Parse(string) (string, error)
}

type ParserBuilder interface {
	// ParserBuilder is an interface that knows how to build parsers
	Columns(structColumnTypes.ColumnDef) ParserBuilder
	Build() Parser
}

type parserBuilder struct {
	// parserBuilders have a columnDef (all the field definitions)
	columnDef structColumnTypes.ColumnDef
}

type parser struct {
	Columns structColumnTypes.ColumnDef
}

// a Struct is either a header or a data DataFields struct
func fillStruct(aStruct interface{}, lineData []string) {
	dataVal := reflect.ValueOf(aStruct)
	for i := 0; i < dataVal.NumField(); i++ {
		switch dataVal.Field(i).Kind() {
		case reflect.Int:
			{
				d, _ := strconv.Atoi(lineData[i])
				dataVal.Field(i).SetInt(int64(d))
			}
		case reflect.Float64:
			{
				d, _ := strconv.ParseFloat(lineData[i], 64)
				dataVal.Field(i).SetFloat(d)
			}
		case reflect.String:
			{
				dataVal.Field(i).SetString(lineData[i])
			}
		case reflect.Bool:
			{
				d, _ := strconv.ParseBool(lineData[i])
				dataVal.Field(i).SetBool(d)
			}
		default:
			{
				fmt.Printf("Unknown type %s\n", dataVal.Field(i).Kind())
			}
		}
	}
}

func (pb *parserBuilder) Columns(columns structColumnTypes.ColumnDef) ParserBuilder {
	pb.columnDef = columns
	return pb
}

func (pb *parserBuilder) Build() Parser {
	myPb := &parser{
		Columns: pb.columnDef,
	}
	// Build only happens to brand new builders so fill in the header fields
	// of the column definition struct
	return myPb
}

var lock = &sync.Mutex{}

func (p *parser) Parse(line string) (string, error) {
	fmt.Printf("Parsing the string: %s from %s\n", line, p.Columns.Name)
	
	return "parsed", nil
}

func getId(headerLine string, dataLine string, fileType string) string {
	// get the lineTypeIndex from the header line
	headerFields := strings.Split(headerLine, ",")
	var id string = ""
	dataFields := strings.Split(dataLine, ",")
	// get the lineType from the header line
	for i, _ := range headerFields {
		id = id + ":" + dataFields[i]
	}
	return id
}

func getLineType(headerLine string, dataLine string, fileType string) string {
	HeaderString := ""
	if fileType == "MODE" {
		parts := strings.Split(headerLine, " OBTYPE ")
		HeaderString = parts[0] + " OBTYPE"
	} else {
		// get the header fields from line
		parts := strings.Split(headerLine, " LINE_TYPE ")
		HeaderString = parts[0] + " LINE_TYPE"
	}
	headerFields := strings.Fields(HeaderString)
	dataFields := strings.Fields(dataLine)
	return dataFields[len(headerFields)]
}

func getParser(headerLine string, dataLine string, fileType string) Parser {
	// get the identifier for the lineType and line
	fileType = strings.ToUpper(fileType)
	id := getId(headerLine, dataLine, fileType)
	lineType := getLineType(headerLine, dataLine, fileType)
	if builderMap[lineType] == nil {
		// create a new parserBuilder and let it build the parser
		// by filling in the header fields of the column definition struct
		// and returning a parser struct with the columns field set to the column definition struct.
		// the parser struct implements the Parser interface by having a Parse method.
		// The Build function will fill in the header fields of the column definition struct.
		pb := &parserBuilder{}
		pMap := structColumnTypes.ParserMap[lineType]
		myParserBuilder := pb.Columns(pMap)
		myParser := myParserBuilder.Build()
		builderMap[lineType] = myParser
	}
	return builderMap[lineType]
}

func ParseIt(headerLine string, dataLine string, fileType string, doc *interface{}) (interface{}, error) {

	// singleton pattern - these are pointers to the parser objects.
	// getParser() returns a pointer to a particular parser implementation mapped to the proper lineType.
	// the parser implementation is a struct that implements the Parser interface by having a Parse method
	// and a Columns field that is a struct that implements the ColumnDef interface.

	lock.Lock()
	parser := getParser(headerLine, dataLine, fileType).(*parser)
	lock.Unlock()
	doc, _err := parser.Parse(headerLine, dataLine, fileType)
	return doc, _err
}
