package structColumnDefs

import (
	"fmt"
	"parser/pkg/structColumnTypes"
	"reflect"
	"strconv"
	"strings"
	"sync"
)

// header type definitions are from the structColumnType package
// and are used to define the header fields of the column definition.
// These types are generated by the buildHeaderLineTypes.go program.

var builderMap = map[string]Parser{}

type Parser interface {
	Parse(string) (string, error)
}

type ParserBuilder interface {
	Columns(structColumnTypes.ColumnDef) ParserBuilder
	Build(string) Parser
}

type parserBuilder struct {
	columnDef structColumnTypes.ColumnDef
}

type parser struct {
	Columns structColumnTypes.ColumnDef
}

// aStruct is either a header or a data DataFields struct
func (pb *parser) fillStruct(aStruct interface{}, lineData []string) {
	dataVal := reflect.ValueOf(aStruct)
	for i := 0; i < dataVal.NumField(); i++ {
		switch dataVal.Field(i).Kind() {
		case reflect.Int:
			{
				d, _ := strconv.Atoi(lineData[i])
				dataVal.Field(i).SetInt(int64(d))
			}
		case reflect.Float64:
			{
				d, _ := strconv.ParseFloat(lineData[i], 64)
				dataVal.Field(i).SetFloat(d)
			}
		case reflect.String:
			{
				dataVal.Field(i).SetString(lineData[i])
			}
		case reflect.Bool:
			{
				d, _ := strconv.ParseBool(lineData[i])
				dataVal.Field(i).SetBool(d)
			}
		default:
			{
				fmt.Printf("Unknown type %s\n", dataVal.Field(i).Kind())
			}
		}
	}
}

func (pb *parserBuilder) Columns(columns structColumnTypes.ColumnDef) ParserBuilder {
	pb.columnDef = columns
	return pb
}

func (pb *parserBuilder) Build(line string) Parser {
	myPb := &parser{
		Columns: pb.columnDef,
	}
	// Build only happens to brand new builders so fill in the header fields
	// of the column definition struct
	headerFieldStruct := reflect.ValueOf(myPb.Columns.Doc).FieldByName("HeaderFields")
	lineData := strings.Fields(line)
	myPb.fillStruct(headerFieldStruct, lineData)
	return myPb
}

var lock = &sync.Mutex{}

func (p *parser) Parse(line string) (string, error) {
	fmt.Printf("Parsing the string: %s from %s\n", line, p.Columns.Name)
	dataFieldStruct := reflect.ValueOf(p.Columns.Doc).FieldByName("DataFields")
	lineData := strings.Fields(line)
	p.fillStruct(dataFieldStruct, lineData)
	return "parsed", nil
}

func getParser(lineType string, line string) Parser {
	if builderMap[lineType] == nil {
		pb := &parserBuilder{}
		pMap := structColumnTypes.ParserMap[lineType]
		myParser := pb.Columns(pMap)
		builderMap[lineType] = myParser.Build(line)
	}
	return builderMap[lineType]
}

func ParseIt(lineType string, line string) (interface{}, error) {
	// singleton pattern - these are pointers to the parser objects.
	// getParsers() returns a pointer to a particular parser implementation mapped to the lineType.
	// the parser implementation is a struct that implements the Parser interface by having a Parse method
	// and a Columns field that is a struct that implements the ColumnDef interface.

	lock.Lock()
	parser := getParser(lineType, line).(*parser)
	lock.Unlock()
	ret, _err := parser.Parse(line)
	return ret, _err
}
